package com.logpresso.scanner.utils;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.Charset;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Set;
import java.util.zip.CRC32;
import java.util.zip.Deflater;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

public class ZipUtils {

	public static boolean isScanTarget(String path, boolean scanZip) {
		String loweredPath = path.toLowerCase();
		if (scanZip && loweredPath.endsWith(".zip"))
			return true;

		// ear = Java EE archive, aar = Android archive
		// rar = Java EE resource adapter archive (not WinRAR)
		// nar = NiFi jar
		return loweredPath.endsWith(".jar") || loweredPath.endsWith(".war") || loweredPath.endsWith(".ear")
				|| loweredPath.endsWith(".aar") || loweredPath.endsWith(".rar") || loweredPath.endsWith(".nar");
	}

	public static void ensureClose(ZipFile zipFile) {
		if (zipFile != null) {
			try {
				zipFile.close();
			} catch (Throwable t) {
			}
		}
	}

	private static boolean isShaded(String s, Set<String> shadePatterns) {
		for (String pattern : shadePatterns) {
			if (s.endsWith(pattern))
				return true;
		}
		return false;
	}

	public static boolean repackage(File srcFile, File dstFile, Set<String> removeTargets, Set<String> shadePatterns,
			boolean scanZip, boolean nested, boolean debug, Charset altCharset) {
		Set<String> entryNames = new HashSet<String>();
		ZipFile srcZipFile = null;
		ZipOutputStream zos = null;

		try {
			Charset charset = altCharset != null ? altCharset : Charset.forName("utf-8");
			srcZipFile = new ZipFile(srcFile, charset);
			zos = new ZipOutputStream(new FileOutputStream(dstFile), charset);

			if (nested) {
				zos.setMethod(ZipOutputStream.STORED);
				zos.setLevel(Deflater.NO_COMPRESSION);
			}

			Enumeration<?> e = srcZipFile.entries();
			while (e.hasMoreElements()) {
				ZipEntry entry = (ZipEntry) e.nextElement();

				if (removeTargets.contains(entry.getName()))
					continue;

				if (isShaded(entry.getName(), shadePatterns))
					continue;

				// skip if duplicated
				if (!entryNames.add(entry.getName()))
					continue;

				if (entry.isDirectory()) {
					ZipEntry newEntry = new ZipEntry(entry.getName());
					if (nested) {
						newEntry.setMethod(ZipEntry.STORED);
						newEntry.setCompressedSize(0);
						newEntry.setSize(0);
						newEntry.setCrc(0);
					}

					zos.putNextEntry(newEntry);

					continue;
				}

				copyZipEntry(srcZipFile, entry, zos, removeTargets, scanZip, nested, altCharset);
			}

			return true;
		} catch (Throwable t) {
			if (debug)
				t.printStackTrace();

			System.out.println(
					"Error: Cannot fix file (" + t.getMessage() + "). rollback original file " + dstFile.getAbsolutePath());
			return false;
		} finally {
			IoUtils.ensureClose(srcZipFile);
			IoUtils.ensureClose(zos);
		}
	}

	private static void copyZipEntry(ZipFile srcZipFile, ZipEntry zipEntry, ZipOutputStream zos, Set<String> removeTargets,
			boolean scanZip, boolean nested, Charset altCharset) throws IOException {
		InputStream is = null;
		try {
			is = srcZipFile.getInputStream(zipEntry);

			ByteArrayOutputStream bos = new ByteArrayOutputStream();

			if (isScanTarget(zipEntry.getName(), scanZip)) {
				copyNestedJar(is, bos, removeTargets, scanZip, altCharset);
			} else {
				byte[] buf = new byte[32768];
				while (true) {
					int len = is.read(buf);
					if (len < 0)
						break;

					bos.write(buf, 0, len);
				}
			}

			byte[] tempBuf = bos.toByteArray();
			ZipEntry entry = new ZipEntry(zipEntry.getName());
			if (nested) {
				entry.setMethod(ZipEntry.STORED);
				entry.setCompressedSize(tempBuf.length);
				entry.setSize(tempBuf.length);
				entry.setCrc(computeCrc32(tempBuf));
			}

			// caller should check duplicated entry
			zos.putNextEntry(entry);
			transfer(new ByteArrayInputStream(tempBuf), zos);

		} finally {
			IoUtils.ensureClose(is);
		}
	}

	private static void copyNestedJar(InputStream is, OutputStream os, Set<String> removeTargets, boolean scanZip,
			Charset altCharset) throws IOException {
		// check duplicated entry exception
		Set<String> entryNames = new HashSet<String>();

		ZipInputStream zis = null;
		ZipOutputStream zos = null;
		try {
			Charset charset = altCharset != null ? altCharset : Charset.forName("utf-8");
			zis = new ZipInputStream(new DummyInputStream(is), charset);
			zos = new ZipOutputStream(os, charset);

			while (true) {
				ZipEntry zipEntry = zis.getNextEntry();
				if (zipEntry == null)
					break;

				if (removeTargets.contains(zipEntry.getName()))
					continue;

				if (zipEntry.isDirectory()) {
					ZipEntry entry = new ZipEntry(zipEntry.getName());

					if (entryNames.add(entry.getName()))
						zos.putNextEntry(entry);

					continue;
				}

				// fix recursively
				ByteArrayOutputStream bos = new ByteArrayOutputStream();
				if (isScanTarget(zipEntry.getName(), scanZip)) {
					copyNestedJar(zis, bos, removeTargets, scanZip, altCharset);
				} else {
					byte[] buf = new byte[32768];
					while (true) {
						int len = zis.read(buf);
						if (len < 0)
							break;

						bos.write(buf, 0, len);
					}
				}

				byte[] outputBuf = bos.toByteArray();
				ZipEntry entry = new ZipEntry(zipEntry.getName());

				if (entryNames.add(entry.getName())) {
					zos.putNextEntry(entry);
					transfer(new ByteArrayInputStream(outputBuf), zos);
				}
			}
		} finally {
			IoUtils.ensureClose(zis);

			if (zos != null)
				zos.finish();
		}
	}

	private static void transfer(InputStream is, OutputStream os) throws IOException {
		byte[] buf = new byte[32768];
		while (true) {
			int len = is.read(buf);
			if (len < 0)
				break;

			os.write(buf, 0, len);
		}
	}

	private static long computeCrc32(byte[] buf) {
		CRC32 crc = new CRC32();
		crc.update(buf, 0, buf.length);
		return crc.getValue();
	}
}
